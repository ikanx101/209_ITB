---
title: "SK5002 ALGORITHM AND SOFTWARE DESIGN"
subtitle: | 
    | Catatan Kuliah
    | Sebuah Usaha untuk Mencatat
author: | 
    | Mohammad Rizka Fadhli (Ikang)
    | 20921004@mahasiswa.itb.ac.id
date: "`r format(Sys.time(), '%d %B %Y')`"
fontsize: 12pt
output: 
  pdf_document:
    number_sections: true
    toc: false
    fig_width: 7
    fig_height: 4
    fig_caption: true
    highlight: breezedark
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyfoot[CO,CE]{20921004@mahasiswa.itb.ac.id}
- \fancyfoot[LE,RO]{hal \thepage}

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/209_ITB/Semester I/Algorithm and Software Design")
library(dplyr)
library(ggplot2)
```

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage

# SILABUS 

## Keterangan Umum 

### Silabus Ringkas	

Pada mata kuliah ini, mahasiswa akan mempelajari dan membahas tentang teknik-teknik pengembangan algoritma yang banyak digunakan, optimasi dan perancangan program berbasis data.

### Silabus Lengkap 

#### Pendahuluan 

Ruang lingkup perkuliahan: 

- Topik-topik terkait dengan perkuliahan, pengantar algoritma; 
- Algoritma pemrograman: 
    - Pengembangan pola berpikir, 
    - Kinerja program, 
    - Algoritma dasar, 
    - _Flow-chart_, 
    - Fungsi, 
    - Pola pemrograman algoritma rekursif. 
- Optimasi Algoritma: 
    - _Bellman Algorithm_, 
    - Pencarian jalan terdekat, pengukuran efisiensi, Dijkstra Algorithm. 
- Aplikasi _Dijkstra_, _Genetic algorithm_, _Holland theory_, aplikasi GA; 
- Perancangan program terstruktur: 
    - Program _design_, _water fall_, _quick_, _proto typing_, pengertian _system_ dan aliran data.
- Rancangan _context diagram_
- Data _Flow_ diagram, basis data, _ERD_.
- Perancangan berbasis object _Unified Model Language_ (UML), aktor, diagram _use-case_, pendefinisian masalah, _activation diagram_ dalam UML, _break down_ problem dalam _use-case_ dan _activity diagram_, _interaction diagram_, _class diagram_, _swim lane_, _collaboration diagram_.

### _Outcomes_ 

1. Mahasiswa akan memahami dan menguasa teknik-teknik pengembangan algoritma dan perancangang program yang banyak digunakan.
1. Mahasiswa akan dapat mengembangkan dan menulis algoritma suatu karya progam dengan baik dan benar menggunakan metoda yang beragam.
1. Mahasiswa akan memiliki pengalaman perancangan suatu system dan program.

### Panduan Penilaian 

```{r,echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Bobot Penilaian"}
data.frame(
  ket = c("Exam","Tugas"),
  persen = c(30,70)
) %>% 
  mutate(label = paste0(ket,"\n",persen,"%")) %>% 
  ggplot(aes(x = reorder(ket,-persen),
             y = persen)) +
  geom_col(aes(fill = label),
           color = "black") +
  geom_label(aes(label = label)) +
  labs(title = "Porsi Penliaian Awal Mata Kuliah",
       subtitle = "Pemrograman dalam Sains",
       caption = "Dibuat dengan R\nikanx101.com") +
  theme_minimal() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        legend.position = "none") +
  coord_polar()
```

\newpage

## Satuan Acara Perkuliahan

```{r out.width="100%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Satuan Acara Perkuliahan"}
knitr::include_graphics("satuan_kuliah.jpg")
```


## Info Lainnya

UTS akan dilaksanakan kira-kira pada minggu ke-8. Setelah itu baru masuk ke topik perancangan perangkat lunak (baru di sini akan ada kerja kelompok). _Ending_-nya presentasi per kelompok.

Semua dikumpulkan via ___Ms. Teams___.

\newpage

# PERTEMUAN MINGGU I 

26 Agustus 2021

## _Computational Thinking_

Ada empat pilar:

1. Dekomposisi.
    - Memecah masalah besar ke masalah-masalah yang lebih kecil sehingga lebih bisa di-_manage_.
1. _Pattern recognition_.
    - Menganalisa dan melihat apakah ada pola atau pengulangan.
1. _Algorithm design_
    - Menuliskan langkah-langkah dalam bentuk formal.
1. _Abstraction_
    - Memisahkan mana yang _important_, mana yang _less important_.


```{r out.width="100%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Computational Thinking"}
knitr::include_graphics("computational thinking.jpg")
```


## _Algorithm_

> ___A set of procedure (step by step) to solve a (sub)problem.___

Bentuknya bisa:

- _Pseudocode_
- _Flowchart_

```{r out.width="100%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Flowchart"}
knitr::include_graphics("x1.jpg")
```

Algoritma biasanya memiliki minimal `3` _control structure_, yakni:

1. _Sequence_
1. _Conditional_
1. _Repetition / loop_

### Contoh {-}

Bagaimana cara mengurutkan bilangan berikut ini:

$$5,8,6,1,3$$

\newpage

#### _Pseudocode_ {-}

Jawaban standarnya seperti ini:

```{r out.width="40%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Contoh Pseudo Code"}
knitr::include_graphics("jawab.jpg")
```

#### _Flowchart_ {-}

Berikut adalah bentuk _flowchart_-nya:

```{r out.width="40%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Contoh Flowchart"}
knitr::include_graphics("x2.jpg")
```

\newpage

#### Jawaban Sendiri Versi 1^[https://ikanx101.com/blog/sort-number/] {-}

Kalau dengan jawaban sendiri, _pseudocode_-nya adalah sebagai berikut:

- __Step 1__: _INPUT_ _vector_ berupa numerik yang tidak berurut, misal dinotasikan sebagai $a$ dengan $n$ buah elemen.
- __Step 2__: Akan saya buat _vector_ $b$ dengan panjang $n$ elemen.
- __Step 3__: $b_1$ akan saya isi dengan angka terendah dari $a$. Setelah dipindahkan, $a$ kini memiliki elemen sebanyak $n-1$.
- __Step 4__: Ulang __step 3__ hingga semua elemen $a$ dipindahkan ke $b$.

```{r}
rm(list=ls())

soal = c(5,8,6,1,3,1,2,-5,2,2,-4)

urut_donk = function(input){
  # set initial condition
  a = input
  n = length(input)
  
  # siapkan vector kosong
  b = c()
  
  # repetition dengan syarat a masih ada
    # dilihat dari panjang n yang masih > 0
  while(n > 0){
    # mengambil elemen terkecil dari a
    min = min(input)
    n_min = length(which(input == min))
    # memindahkan elemen tersebut ke dalam b
    b = c(b,
          rep(min,n_min)
          )
    # menghapus elemen a yang sudah dipindahkan
    input = input[!input %in% b]
    n = length(input)
  }
  
  output = list(`Data asli` = a,
                `Hasil terurut` = b)
  return(output)
}

urut_donk(soal)
```

#### Jawaban Sendiri Versi 2^[https://ikanx101.com/blog/sort-number/] {-}

Bagaimana jika kita tidak boleh menggunakan fungsi lain selain _looping_, _conditional_, dan `length()`?

Caranya hampir mirip dengan _flowchart_ di atas, yakni:

1. _Input_ _vector_ yang hendak diurutkan, misal notasi $a$. 
    - Hitung ada berapa _elemen_ yang ada, misal notasi $n$.
1. Bandingkan $a_1$ dengan elemen di sebelahnya.
    - Jika $a_1 > a_2$ maka tukar posisi.
    - Lanjutkan perbandingan $a_1$ dengan elemen selanjutnya hingga elemen ke-$n$.
1. Lanjutkan perbandingan untuk elemen kedua dan seterusnya.

```{r}
rm(list=ls())

urut_lagi_donk = function(a){
  # set initial condition
  input = a
  n = length(a)

  # looping
  for(i in 1:(n-1)){
    for(j in (i+1):n){
      temp1 = a[i] # temporary
      temp2 = a[j]  # temporary
      if(temp1 > temp2){
        # proses penukaran
        a[i] = temp2
        a[j] = temp1
        }
      }
    }
  # menulis hasilnya
  hasil = list(
    `Data asli` = input,
    `Hasil terurut` = a
  )
  # print output
  return(hasil)
}

soal = c(9,8,6,1,3,1,-10)

urut_lagi_donk(soal)
```

\newpage

# PERTEMUAN MINGGU II
2 September 2021

## _Algorithm Design_

Algoritma disusun setidaknya memiliki tiga _control structure_, yakni:

1. _Sequence_,
1. _Conditional_,
1. _Repetition_ atau _loop_.

Algoritma dibuat sesuai dengan kreativitas masing-masing. Bisa jadi jalan seseorang berbeda dengan orang lainnya. Untuk membandingkan algoritma mana yang terbaik, kita bisa cek dua parameter ini:

1. _Running time_ terkecil.
1. _Memory used_ (__RAM__) terkecil.

## Algoritma Sederhana

### _Case Study_ I

Buatlah algoritma yang bisa mengecek suatu bilangan adalah bilangan prima atau bukan!

```{r}
rm(list=ls())

is_prime = function(n){
  hasil = NA
  temp_1 = 0
  if(n > 1){
    for(i in 2:n){
      temp_2 = n %% i == 0
      temp_2 = temp_1 + temp_2
      hasil = ifelse(temp_2 == 0,
                     "Prime",
                     "Not Prime")
    } 
  } else{
      hasil = "Bilangan < 1"
    }
  return(hasil)
}

is_prime(4)
```



\newpage

## Quiz

### Soal 1 {-}

> _Construct Pascal's triangle!_

```{r}
rm(list=ls())

# ide dasarnya adalah hanya dengan menggeser baris atas ke bawah
  # lalu geser ke kiri
  # lalu geser ke kanan

pascal = function(n){
  # initial
  x = 1
  print(x)
  for(i in 2:n){
    x = c(0,x) + c(x,0)
    print(x)
  }
}

# kita uji coba ya
pascal(15)
```

\newpage

### Soal 2 {-}

> _Find n-th Fibonacci number_: $F_n = F_{n-1} + F_{n-2}, F_0 = 0, F_1 = 1$ 

```{r}
rm(list=ls())

# set initial condition
f = c(0,1)

# karena basis di R dimulai dari 1 sedangkan Fibonacci dimulai dari 0
  # maka nanti indexing akan dibuat kurang 1
  # proses deduksi
n = 10
for(i in 2:n){
  f[i+1] = f[i] + f[i-1]
}

# berikut adalah hasilnya:
f
```

Atas dasar ini kita akan buat _function_-nya sebagai berikut:

```{r}
fibo = function(n){
  f = c(0,1)
  for(i in 2:n){
  f[i+1] = f[i] + f[i-1]
  }
  return(list(`Fibonacci Seq` = f,
              `nth Fibo Number` = max(f))
         )
}

# saatnya uji coba
fibo(10)
```

\newpage
### Soal 3 {-}

> _Bikin algoritma faktorial!_

Untuk memudahkan pembuatan algoritma, kita akan melihat kembali definisi dari faktorial^[https://id.wikipedia.org/wiki/Faktorial] sebagai berikut:

$$n! = (n)(n-1)(n-2)..(1)$$

Dengan syarat $n \geq 0$ dan $n$ berupa _integer_. Namun perlu diperhatikan bahwa $0! = 1$.

Oleh karena itu, kita bisa menggunakan prinsip rekursif dengan algoritma dalam _pseudocode_ berikut ini:

#### Algoritma dalam _Pseudocode_ {-}

```
INPUT n

IF n NOT INTEGER OR n < 0 STOP

IF n = 0 OR n = 1 RETURN 1

ELSE 

DEFINE a = 1

FOR i 2:n
  a = a*i
RETURN a
```

Bentuk _flowchart_ dari _pseudocode_ di atas adalah sebagai berikut:

\newpage

#### Algoritma dalam _Flowchart_ {-}

```{r out.width="50%",echo=FALSE,fig.align='center',fig.cap = "Flowchart Faktorial"}
nomnoml::nomnoml("#direction: down,
                 [<start> start] -> [<choice> Integer?\nAND\nn>0]
                 [<choice> Integer?\nAND\nn>0] -> NO[<usecase> STOP]
                 [<choice> Integer?\nAND\nn>0] -> YES[<choice> n<=1]
                 [<choice> n<=1] -> YES[Return 1]
                 [<choice> n<=1] -> NO[a = 1\ni = 2]
                 [a = 1\ni = 2] -> [<choice> i <= n]
                 
                 [<choice> i <= n] -> YES [a = a * i]
                 [a = a * i] -> [i = i + 1]
                 [<choice> i <= n] <- [i = i + 1]
                 
                 [<choice> i <= n] -> NO [Return a]
                 
                 [Return a] -> [<end> stop]
")
```

\newpage

#### __R__ _function_ {-}

Sekarang algoritma di atas jika dibuat __R__ _function_-nya adalah sebagai berikut:

```{r}
f_torial = function(n){
  # initial definition
  hasil = 1
  
  # conditional
  if(n < 0){hasil = "n yang dimasukkan < 0"}
    else if(n %in% c(0,1)){hasil = 1}
      else{
        for(i in 2:n){
          hasil = hasil*i
          }
      }
  
  # return output perhitungan
  output = list(
    `Input angka` = n,
    `n!` = hasil
  )
  
  # print output
  return(output)
}
```

Mari kita cek hasilnya dalam berbagai kondisi berikut:

```{r}
f_torial(-2)
f_torial(0)
f_torial(1)
f_torial(4)
f_torial(7)
f_torial(10)
```

\newpage

# PERTEMUAN MINGGU III
9 September 2021

## _Numerical Method_


### Mencari Akar Persamaan

#### _Bisection Method_ {-}

Ini mirip dengan mata kuliah __Analisis Numerik Lanjut__ SK5001. Dari mata kuliah sebelumnya, saya modifikasi penentuan _error_ menjadi $(b-a) < tol_{max}$ sehingga _function_-nya menjadi:

```{r}
rm(list=ls())

bagi_dua = function(a,b,f,iter_max,tol_max){
  # fungsi untuk grafik
    # set nilai x
      baris = seq(a,b,by = .05)
    # nilai y
      y = f(baris)
    # bikin plotnya
      plot = 
        data.frame(x = baris,y) %>% 
        ggplot(aes(x,y)) +
        geom_line(group = 1,
                  color = "darkblue") +
        coord_equal() +
        geom_hline(yintercept = 0)
  
  # fungsi hitung bisection
    # initial condition
    i = 1
    hasil = data.frame(n_iter = NA,
                       a = NA,
                       b = NA,
                       c = NA)

    while(i<= iter_max && (b-a) > tol_max){
      # cari titik tengahnya
      p = a + ((b-a)/2)
      # hitung fungsi di titik tengah
      FP = f(p)
      # hitung fungsi di titik awal
      FA = f(a)
      # hitung fungsi di titik akhir
      FB = f(b)
      # tulis hasil dalam data frame
      hasil[i,] = list(i,a,b,p)
      
      # tukar nilai a atau b dengan nilai p 
      if(FA*FP < 0){b = p} else{a = p}
      # untuk iterasi berikutnya
      i  = i + 1
      
      # mencatat akar persamaan
      akar = p
      # tambahin dulu checking apakah f(a), f(b),atau f(c) ada yang nol?
      if(FP == 0){
        akar = p
        break} else if(FA == 0){
          akar = a
          break} else if(FB == 0){
            akar = b
            break}
      
    }
  
  # mencatat iterasi terbesar
  iterasi = i-1 # dikurang satu karena pada i+1 
                # sebenarnya tidak ada proses jika pada while TRUE
  
  # membuat ouput
  hasil = list(
    `plot f(x) di selang [a,b]` = plot,
    `iterasi max` = iterasi,
    `akar persamaan` = akar,
    `hasil perhitungan` = hasil
    )
  
  # print output
  return(hasil)
}
```

\newpage

Pada metode ini, pemilihan selang menjadi krusial. Contohnya adalah $f(x) = x^2 - 1$ di selang $[0.5,3]$.

```{r}
a = 0
b = 2
f = function(x){x^2-1}
iter_max = 50
tol_max = 10^(-7)

bagi_dua(a,b,f,iter_max,tol_max)
```

#### Contoh Lainnya {-}

$f(x) = x^2 - 3 x + 2$ di selang $[1.8,2.2]$.

### Luas Area di Bawah Kurva

Ide dasarnya adalah $L = alas.tinggi$, dimana:

1. $alas$ bisa didefinisikan sebagai $\Delta x = x_2 - x_1$.
1. Sedangkan definisi $tinggi$ tergantung bidang yang dipilih.
    - Jika kita menggunakan _square_ di titik tengah $\Delta x$, maka $tinggi = f(\frac{x_1+x_2}{2})$.
    - Jika kita menggunakan _trapezoid_, maka $tinggi = \frac{f(x_1) + f(x_2)}{2}$.
    
Algoritmanya:

```{r}
rm(list=ls())

persegi = function(x0,xn,n){
  h = (xn - x0) / n
  integration = f(x0)
  for(i in 1:n){
    k = x0 + i*h
    integration = integration + f(k)
  }
  integration = integration * h
  return(integration)
}

# bikin sendiri
trapezoid = function(x0,xn,n){
  h = (xn - x0) / n
  f0 = f(x0)
  # selang pertama
  i = 1
  k = x0 + i*h
  fn = f(k)
  integration = (f0+fn)/2
  for(i in 2:n){
    f0 = fn
    k = x0 + i*h
    fn = f(k)
    temp = (f0+fn)/2
    integration = integration + temp
  }
  integration = integration * h
  return(integration)
}

# dari dosen
trapezoidal = function(x0,xn,n){
  h = (xn - x0) / n
  integration = f(x0) + f(xn)
  
  for(i in 1:n){
    k = x0 + i*h
    integration = integration + 2*f(k)
  }
  integration = integration * h/2
  return(integration)
}

f = function(x){1/(1 + x^2)}
a = 2
b = 5

data.frame(x = seq(a,b,by = .01)) %>% 
  mutate(y = f(x)) %>% 
  ggplot(aes(x,y)) +
  geom_line()

persegi(2,5,90000)
trapezoid(2,5,90000)
trapezoidal(2,5,90000)
```

### Solusi Persamaan Diferensial

$$\frac{dy}{dt} = f(t,y)$$

Harus diketahui minimal `1` _initial condition_, misal: $y(t_0) = y_0$.

Kita akan selesaikan dengan metode __Runge-Kutta__ order 4. Bentuk umumnya adalah sebagai berikut:

$$y_{n+1} = y_n + h \sum_{i=1}^n b_i k_i$$

dimana $k_i$ adalah konstanta yang harus dicari.

```{r}
rk_4order = function(f, x0, y0, h, n){
  # initial condition
  x = x0
  y = y0
  # proses iterasi
  for(i in 1:n){
    k1 = f(x0,y0)
    k2 = f(x0 + 0.5*h,y0 + 0.5*k1*h)
    k3 = f(x0 + 0.5*h,y0 + 0.5*k2*h)
    k4 = f(x0 + h,y0 + k3*h)
    y0 = y0 + (1/6)*(k1 + 2*k2 + 2*k3 + k4) * h
    x0 = x0 + h
    x = c(x, x0)
    y = c(y, y0)
  }
  # output
  output = data.frame(x = x,
                      y = y)
  return(output)
}
```

#### Contoh Soal

_Based on the following differential equation:_

$$\frac{d}{dt}y(t) = t \sqrt{y(t)}; y(0)=1$$

_Define_ $y(t)$ _for t = 0,1,2,..,10 by using 4th order Runge-Kutta!_ _Use h=0.1_.

_Compare the result with the following exact solution:_

$$y(t) = \frac{1}{16}(t^2+4)^2$$

Sekarang kita akan hitung bagaimana hasilnya:

```{r}
dydt = function(t,y){t * sqrt(y)}
y0 = 1
t0 = 0
h = 0.1
n = 100

hampiran = 
  rk_4order(f = dydt, 
            x0 = t0, 
            y0 = y0, 
            h = h, 
            n = n)
```

Lalu akan saya bandingkan hasilnya dari perhitungan _exact_ dan menghitung $\Delta = numerik - exact$ berikut:

```{r,echo=TRUE,message=FALSE,warning=FALSE}
y = function(t){(1/16)*(t^2 + 4)^2}
exact = 
  data.frame(t = seq(0,10,by = h)) %>% 
  mutate(y = y(t)) 
```

```{r,include=FALSE}
hampiran = 
  hampiran %>%  
  rename(t = x,
         y_numerik = y) 

exact = 
  exact %>%  
  rename(y_exact = y) 

final = 
  hampiran %>% 
  mutate(y_exact = exact$y_exact,
         t = as.numeric(t),
         delta = y_numerik - y_exact) 
```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
final %>% 
  knitr::kable("simple",
               caption = "Hasil Perhitungan Exact vs Numerik (RK4)")
```


\newpage

# PERTEMUAN MINGGU IV
16 September 2021

## _Algorithm Design: Randomness_

### Simulasi Monte Carlo

Menggunakan Simulasi _Monte Carlo_ untuk menghitung luas integral. Cara kerjanya simpel, analoginya adalah melempar _darts_. Luas area di bawah kurva dihitung dengan cara:

$$L = \frac{darts_{ \text{on target} }} {darts_{ \text{All} }}$$

Metode ini merupakan metode _brute force_.

### _Flowchart_ Simulasi Monte Carlo

Berikut adalah flowchartnya:

```{r out.width="40%",echo=FALSE,message=FALSE,warning=FALSE,fig.align = "center",fig.cap="Flowchart Brute Force"}
nomnoml::nomnoml("#direction: down,
                 [<start> start] -> [<input> f(x), a, b, N]
                 [<input> f(x), a, b, N] -> [PENENTUAN BATAS|sb x: dari a - b|sb y: dari 0 - max(f(x)) di selang a - b|on_target = 0|i = 0]
                 [PENENTUAN BATAS] -> [<choice> i <= N]
                 
                 [<choice> i <= N] -> N [return (on_target/N)]
                 [return (on_target/N)] -> [<end> end]
                 
                 [<choice> i <= N] -> Y [GENERATE RANDOM|xi,yi di batas sb x dan sb y]
                 [GENERATE RANDOM] -> [<choice> yi <= f(xi)]
                 [<choice> yi <= f(xi)] -> Y [on_target = on_target + 1]
                 [<choice> yi <= f(xi)] -> N [i = i+1]
                 [on_target = on_target + 1] -> [i = i+1]
                 [i = i+1] -> [<choice> i <= N]
                 ")
```

\newpage


### Modifikasi Simulasi Monte Carlo

Kalau pakai simulasi Monte Carlo yang sebelumnya, kita terlalu _brute force_ sehingga secara komputasi akan butuh waktu lebih lama dan _generate random_ titik lebih lama. Oleh karena itu kita bisa memodifikasi menjadi sebagai berikut:

Idenya:

$$I = \int_z^b f(x)dx$$

dihitung sebagai:

$$<F^N> = \frac{b-a}{N+1} \sum_{i=0}^N f(a + (b-a) \xi_i)$$

dengan

$$\xi_i \text{ adalah random number antara 0 dan 1}$$

### _Flowchart_ Modifikasi Simulasi Monte Carlo

```{r out.width="40%",echo=FALSE,message=FALSE,warning=FALSE,fig.align = "center",fig.cap="Flowchart Modifikasi Monte Carlo"}
nomnoml::nomnoml("#direction: down,
                 [<start> start] -> [<input> f(x), a, b, N]
                 [<input> f(x), a, b, N] -> [DEFINE|sum = 0|i = 1]
                 [DEFINE] -> [<choice> i <= N]
                 
                 [<choice> i <= N] -> N [return (sum * (b-a) / N)]
                 [return (sum * (b-a) / N)] -> [<end> end]
                 
                 [<choice> i <= N] -> Y [GENERATE RANDOM|xi di selang a - b]
                 [GENERATE RANDOM] -> [sum = sum + (b-a)*f(xi)]
                 [sum = sum + (b-a)*f(xi)] -> [i = i + 1]
                 [i = i + 1] -> [<choice> i <= N]
                 ")
```

\newpage

# PERTEMUAN MINGGU V

## _Shortest Path Problems_

> Menggunakan energi seminimum mungkin untuk menyusui _path_ tertentu.

Dalam membuat beberapa algoritma, saya akan menggunakan pendekatan struktur data seperti _data frame_ sebagai inputnya.

### _Breadth-First Search_

Algoritma sederhana untuk mencari rute di graf. Misalkan:

Graf $G = (V,E)$

Dengan $V$ adalah _vertex_.

Cara kerjanya adalah ___systematically explores___ semua kemungkinan _vertexes_ yang bisa dilalui lalu mencari _smallest number_ yang ada. Rute terpendek kemudian akan dicari.

Nanti setiap _vertexes_ yang terlewati akan diberikan bobot. Rute terpendek akan ditemukan dari sana.

### _Bellman-Ford_

Perbedaan algoritma ini dengan algoritma sebelumnya adalah __dimungkinkan ada bobot yang negatif__. Namun tidak boleh ada ___negative cycle___.

#### Soal Contoh {-}

```{r,include=FALSE}
rm(list=ls())
data = data.frame(
  label = c("s","t","x","y","z"),
  x = c(0,2,4,2,4),
  y = c(0,5,5,-5,-5)
)

graf = 
  ggplot() +
  # s-t
  geom_segment(aes(x=0,xend=2-.1,
                   y=0,yend=5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # s-y
  geom_segment(aes(x=0,xend=2-.1,
                   y=0,yend=-5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # t-x
  geom_curve(aes(x=2,xend=4-.1,
                 y=5,yend=5-.1),
             arrow = arrow(length = unit(.2,"cm"))) +
  # x-t
  geom_segment(aes(x=4,xend=2+.1,
                   y=5,yend=5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # t-z
  geom_segment(aes(x=2,xend=4-.1,
                   y=5,yend=-5+.5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # t-y
  geom_segment(aes(x=2,xend=2,
                   y=5,yend=-5+.5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # y-z
  geom_segment(aes(x=2,xend=4-.1,
                   y=-5,yend=-5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # y-x
  geom_segment(aes(x=2,xend=4-.1,
                   y=-5,yend=5-.5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # z-x
  geom_segment(aes(x=4,xend=4,
                   y=-5,yend=5-.5),
               arrow = arrow(length = unit(.2,"cm"))) +
  # z-s
  geom_segment(aes(x=4,xend=0+.1,
                   y=-5,yend=0+.1),
               arrow = arrow(length = unit(.2,"cm"))) +
  geom_label(data = data,
             aes(x = x, 
                 y = y,
                 label = label),
             size = 7) +
  theme_void()
```

Jalankan _Bellman-Ford Algorithm_ dengan titik $z$ sebagai titik awal!

```{r out.width="60%",echo=FALSE,warning=FALSE,message=FALSE,fig.retina=10,fig.align='center',fig.cap="Graf Soal I"}
graf_soal = 
  graf +
  # s-t = 6
  annotate("text",x = 1,y=3,label = "6") +
  # s-y = 7
  annotate("text",x = 1,y=-3,label = "7") +
  # t-x = 5
  annotate("text",x = 3,y=3.4,label = "5") +
  # x-t = -2
  annotate("text",x = 3,y=4.6,label = "-2") +
  # z-x = 7 
  annotate("text",x = 3.9,y=0,label = "7") +
  # y-z = 9
  annotate("text",x = 3,y=-4.8,label = "9") +
  # t-y = 8
  annotate("text",x = 2.1,y=1,label = "8") +
  # z-s = 2 
  annotate("text",x = 1,y=-0.5,label = "2") +
  # y-x = -3
  annotate("text",x = 2.6,y=-1.5,label = "-3") +
  # t-z = -4
  annotate("text",x = 3.5,y=-3,label = "-4")

graf_soal
```

\newpage

#### Jawab {-}

Kita akan bikin dulu algoritmanya. _Feeding_-nya kita buat sebagai `data.frame()` saja. Prinsipnya sederhana, yakni melakukan _relaxation_ semua kemungkinan _edges_ dari graf yang ada.

```{r,echo=FALSE}
graf_df = data.frame(from  = c('s','s','t','t','t','y','y','x','z','z'),
                     to    = c('y','t','x','y','z','x','z','t','x','s'),
                     bobot = c(7,6,5,8,-4,-3,9,-2,7,2))
graf_df

d_titik = data.frame(titik = c("z","t","y","x","s"),
                     bobot = c(0,Inf,Inf,Inf,Inf)
                     )
d_titik
```

Berikut adalah panduan melakukan _relaxation_ di semua _shortest path algorithm_^[https://www.youtube.com/watch?v=FtN3BYH2Zes]:

```
if d[u] + c(u,v) < d[v]
   d[v] = d[u] + c(u,v)
```

Sederhana kan?

Berikut dalam __R__-nya:

```{r,echo=TRUE}
# fungsi yang dbutuhkan
# ambil bobot edges dari u ke v
c = function(u,v){
  temp = 
    graf_df %>% 
    filter(from == u) %>% 
    filter(to == v)
  temp$bobot
}

# nilai node u
d = function(u){
  temp = 
    d_titik %>% 
    filter(titik == u)
  temp$bobot
}

# update node v
upd = function(v,value){
  d_titik$bobot[d_titik$titik == v] <<- value
}

# proses iterasi
for(ikanx in 1:10){ # diulang berkali-kali
for(init in d_titik$titik){
  temp = graf_df %>% filter(from == init)
  for(u in temp$from){
    for(v in temp$to){
      if(d(u) + c(u,v) < d(v)){
            val = d(u) + c(u,v)
            upd(v,val)
        }
    }
  }
}
}

d_titik
```

\newpage

Lihat kembali grafnya:

```{r out.width="60%",echo=FALSE,warning=FALSE,message=FALSE,fig.retina=10,fig.align='center',fig.cap="Graf Soal I"}
graf_soal = 
  graf +
  # s-t = 6
  annotate("text",x = 1,y=3,label = "6") +
  # s-y = 7
  annotate("text",x = 1,y=-3,label = "7") +
  # t-x = 5
  annotate("text",x = 3,y=3.4,label = "5") +
  # x-t = -2
  annotate("text",x = 3,y=4.6,label = "-2") +
  # z-x = 7 
  annotate("text",x = 3.9,y=0,label = "7") +
  # y-z = 9
  annotate("text",x = 3,y=-4.8,label = "9") +
  # t-y = 8
  annotate("text",x = 2.1,y=1,label = "8") +
  # z-s = 2 
  annotate("text",x = 1,y=-0.5,label = "2") +
  # y-x = -3
  annotate("text",x = 2.6,y=-1.5,label = "-3") +
  # t-z = -4
  annotate("text",x = 3.5,y=-3,label = "-4")

graf_soal
```

#### Kesimpulan {-}

Rutenya adalah __z-s-y-x-t__.

\newpage

### Dijkstra

Kalau __Dijkstra__ hanya bisa digunakan pada graf dengan bobot _edges_ __positif__. Algoritmanya berbeda dengan _Bellman-Ford_. __Dijkstra__ hanya memilih _vertex_ dengan bobot terendah untuk kemudian dilakukan _relaxation_.

#### Contoh Kasus {-}

Perhatikan graf berarah berikut ini:

```{r out.width="90%",echo=FALSE,warning=FALSE,message=FALSE,fig.retina=10,fig.align='center',fig.cap="Graf Soal Dijkstra"}

rm(list=ls())

graf_dj = 
  ggplot() +
  # definisi titik
  geom_label(aes(x = 0,y = 1,label = "1")) +
  geom_label(aes(x = 1,y = 2,label = "2")) +
  geom_label(aes(x = 1,y = 0,label = "3")) +
  geom_label(aes(x = 2,y = 2,label = "4")) +
  geom_label(aes(x = 2,y = 0,label = "5")) +
  geom_label(aes(x = 3,y = 1,label = "6")) +
  # definisi edges
  # 1-2
  geom_segment(aes(x=0+.1,xend=1-.1,
                   y=1+.1,yend=2),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 1-3
  geom_segment(aes(x=0+.1,xend=1-.1,
                   y=1-.1,yend=0),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 2-3
  geom_segment(aes(x=1,xend=1,
                   y=2-.1,yend=0+.1),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 4-5
  geom_segment(aes(x=2,xend=2,
                   y=0+.1,yend=2-.1),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 2-4
  geom_segment(aes(x=1+.1,xend=2-.1,
                   y=2,yend=2),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 3-5
  geom_segment(aes(x=1+.1,xend=2-.1,
                   y=0,yend=0),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 4-6
  geom_segment(aes(x=2+.1,xend=3-.1,
                   y=2,yend=1+.1),
               arrow = arrow(length = unit(.2,"cm"))) +
  # 5-6
  geom_segment(aes(x=2+.1,xend=3-.1,
                   y=0,yend=1-.1),
               arrow = arrow(length = unit(.2,"cm"))) +
  theme_void() +
  # 1-2 = 2
  annotate("text",x = 0.5,y=1.4,label = "2") +
  # 1-3 = 4
  annotate("text",x = 0.5,y=0.6,label = "4") +
  # 2-4 = 7
  annotate("text",x = 1.5,y=1.9,label = "7") +
  # 3-5 = 3
  annotate("text",x = 1.5,y=0.1,label = "3") +
  # 2-3 = 1
  annotate("text",x = 1.1,y=1,label = "1") +
  # 4-5 = 2
  annotate("text",x = 2.1,y=1,label = "2") +
  # 4-6 = 1
  annotate("text",x = 2.5,y=1.4,label = "1") +
  # 5-6 = 5
  annotate("text",x = 2.5,y=.6,label = "2") 
  
  
graf_dj
```

Jika kita mulai dari _vertex_ `1`, tentukan _shortest path_ ke semua _vertexes_-nya!

Mari kita mulai algoritma __Dijkstra__-nya:

__STEP 1__ Dari `1` kita bisa memilih ke `2` atau `3`. Akibatnya $d[2] = 2$ dam $d[3] = 4$. Sementara itu $d[4] = d[5] = d[6] = \infty$.

Kita hapus _vertex_ `1` dari graf.

__STEP 2__ Karena $d[2]$ memiliki nilai terkecil __dari semua vertexes__, maka kita akan pilih `2` sebagai __awal baru__. Pada _step_ ini kita akan mulai melakukan _relaxation_. Dari `2` kita bisa memilih ke `3` atau `4`. Akibatnya:

- $d[4] = 9$.
- $d[3]$ di-_update_ menjadi $d[3]=3$.
- $d[5] = d[6] = \infty$.
  
Kita hapus _vertex_ `2` dari graf.
  
__STEP 3__ Karena $d[3]$ memiliki nilai terkecil __dari semua vertexes__, maka kita akan pilih `3` sebagai __awal baru__. _Vertex_ `3` hanya bisa ke `5`. Akibatnya:

- $d[4] = 9$.
- $d[5] = 6$.
- $d[6] = \infty$.

Kita hapus _vertex_ `3` dari graf.

__STEP 4__ Karena $d[5]$ memiliki nilai terkecil __dari semua vertexes__, maka kita akan pilih `5` sebagai __awal baru__. _Vertex_ `5` bisa ke `4` atau `6`. Akibatnya:

- _Update_ nilai $d[4] = 8$.
- $d[6] = 11$.

Kita hapus _vertex_ `5` dari graf.

__STEP 5__ Karena $d[4]<d[6]$ maka kita akan pilih `4` sebagai awal baru dan hanya bisa ke `6`. Akibatnya $d[6] = 9$.

#### Kesimpulan {-}

Maka rutenya adalah: __1-2-3-5-4-6__ dengan jarak final berikut:

```{r,echo=FALSE}
data.frame(u      = c(1,2,3,5,4,6),
           `d[u]` = c(0,2,3,6,8,9)) %>% 
  knitr::kable("simple",align = "c",caption = "Rute Final Dijkstra")
```

#### __R__ _Function_ Dijkstra {-}

Dengan prinsip yang sama dengan _function_ _Bellman-Ford_:

Inputnya dalam bentuk _data frame_ berikut:

```{r}
graf_df = data.frame(from  = c(1,1,2,2,3,4,5,5),
                     to    = c(2,3,3,4,5,6,4,6),
                     bobot = c(2,4,1,7,3,1,2,2)
                     )
graf_df

d_titik = data.frame(titik = 1:6,
                     bobot = c(0,rep(Inf,5))
                     )
d_titik
```

Berikut adalah _function_-nya:

```{r}
# fungsi yang dbutuhkan
# ambil bobot edges dari u ke v
c = function(u,v){
  temp = 
    graf_df %>% 
    filter(from == u) %>% 
    filter(to == v)
  temp$bobot
}

# nilai node u
d = function(u){
  temp = 
    d_titik %>% 
    filter(titik == u)
  temp$bobot
}

# update node v
upd = function(v,value){
  d_titik$bobot[d_titik$titik == v] <<- value
}

hasil = data.frame(titik = NA,bobot = NA)

for(ikang in 1:nrow(d_titik)){
  # kita mulai
  init = d_titik %>% filter(bobot == min(bobot)) %>% select(titik)
  init = init$titik[1]

  temp = graf_df %>% filter(from == init)
  i = 1
  while(i <= nrow(temp)){
    u = temp$from[i]
    v = temp$to[i]
    if(d(u) + c(u,v) < d(v)){
              val = d(u) + c(u,v)
              upd(v,val)}
  i = i + 1
  }
  hasil[ikang,] = d_titik %>% filter(titik == init)
  d_titik = d_titik %>% filter(titik != init)
  ikang = ikang+1
}

hasil
```

Perhatikan bahwa _flaw_ terjadi pada _step_ terakhir di mana bobot _edges_ dari vertex `4` ke `6` sebesar `1` belum dimasukkan.

> Oleh karena itu perlu diperhatikan pada saat __closing__ jangan sampai ada yang terlewat.

```{r,include=FALSE}
rm(list = ls())
```

\newpage

#### __R__ _Function_ dari Sumber Lain {-}

Saya menemukan satu _function_ untuk melakukan algoritma Dijkstra di internet^[https://www.algorithms-and-technologies.com/dijkstra/r] sebagai berikut:

```{r}
dijkstra <- function(graph, start){
  #' Implementation of dijkstra using adjacency matrix.
  #' This returns an array containing the length of the shortest 
    # path from the start node to each other node.
  #' It is only guaranteed to return correct results if there are no 
    # negative edges in the graph. Positive cycles are fine.
  #' This has a runtime of O(|V|^2) (|V| = number of Nodes), 
    # for a faster implementation see @see ../fast/Dijkstra.java (using adjacency lists)
  #' @param graph an adjacency-matrix-representation of the graph where (x,y) 
    # is the weight of the edge or 0 if there is no edge.
  #' @param start the node to start from.
  #' @return an array containing the shortest distances from the given start 
    # node to each other node
  
  
  # This contains the distances from the start node to all other nodes
  distances = rep(Inf, nrow(graph))
  
  # This contains whether a node was already visited
  visited = rep(FALSE, nrow(graph))
  
  # The distance from the start node to itself is of course 0
  distances[start] = 0
  
  # While there are nodes left to visit...
  repeat{
    
    # ... find the node with the currently shortest distance from the start node...
    shortest_distance = Inf
    shortest_index = -1
    for(i in seq_along(distances)) {
      # ... by going through all nodes that haven't been visited yet
      if(distances[i] < shortest_distance && !visited[i]){
        shortest_distance = distances[i]
        shortest_index = i
      }
    }
    
    cat("Visiting node ", shortest_index, 
        " with current distance ", shortest_distance, "\n")
    
    if(shortest_index == -1){
      # There was no node not yet visited --> We are done
      return (distances)
    }
    # ...then, for all neighboring nodes that haven't been visited yet....
    for(i in seq_along(graph[shortest_index,])) {
      # ...if the path over this edge is shorter...
      if(graph[shortest_index,i] != 0 && distances[i] > 
         distances[shortest_index] + graph[shortest_index,i]){
        # ...Save this path as new shortest path.
        distances[i] = distances[shortest_index] + graph[shortest_index,i]
        cat("Updating distance of node ", i, " to ", distances[i], "\n")
      }
      # Lastly, note that we are finished with this node.
      visited[shortest_index] = TRUE
      cat("Visited nodes: ", visited, "\n")
      cat("Currently lowest distances: ", distances, "\n")
    }
  }
}

```


Mari kita coba dengan kasus sebelumnya. Jika pada sebelumnya saya membuat _input_ dari _data frame_ kali ini saya mengkonversi _dataframe_ tersebut ke dalam bentuk matriks.

```{r,message=FALSE,warning=FALSE}
# perhatikan ada modifikasi pada bagian 1-1 dan 6-6 agar matriks 
# yang dihasilkan sempurna dimensinya nxn
graf_df = data.frame(from  = c(1,1,2,2,3,4,5,5,1,6),
                     to    = c(2,3,3,4,5,6,4,6,1,6),
                     bobot = c(2,4,1,7,3,1,2,2,0,0)
                     )
graf_new = 
  graf_df %>% 
  reshape2::dcast(from~to,
                  value.var = "bobot") %>% 
  select(-from)

graf_new[is.na(graf_new)] = 0
graf_new = as.matrix(graf_new)

graf_new
```

```{r}
dijkstra(graf_new,1)
```

Perhatikan bahwa hasilnya sama dengan yang sudah saya kerjakan sebelumnya.

\newpage

### _A-star_ $(A^*)$ Algorithm

Menggunakan _heuristic function_ untuk menentukan _path_ mana yang harus dipilih.

_Heuristic functions_ yang bisa dipilih:

1. __Euclidean distance__: $h = \sqrt{(x - x')^2 + (y - y')^2}$.
1. __Manhattan distance__: $h = |x - x'| + |y - y'|$.
1. __Diagonal distance__: $h = \max{ \{ |x-x'|,|y-y'|\} }$.

Jadi akan ada dua value, yakni bobot _edges_ dan nilai _heuristic_ per _vertex_.

#### Contoh Soal {-}

Perhatikan soal berikut ini:

```{r out.width="50%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Contoh Soal A Star"}
knitr::include_graphics("Screenshot from 2021-10-13 20-36-20.png")
```

\newpage

Untuk menyelesaikannya, kita harus membuat dua buah tabel pembantu perhitungan sebagai berikut:

```{r,echo=FALSE}
data.frame(node = rep(" ",4),
           `g-score` = rep(" ",4),
           `f-score` = rep(" ",4),
           previous = rep(" ",4)) %>% knitr::kable(caption = "Unvisited List")

data.frame(node = rep(" ",4),
           `g-score` = rep(" ",4),
           `f-score` = rep(" ",4),
           previous = rep(" ",4)) %>% knitr::kable(caption = "Visited List")
```

Definisikan:

$$\text{g-score} = \sum \omega_{i}$$

Di mana $i$ adalah semua _vertexes_ yang dilalui.

$$\text{f-score} = \omega_{edges} + \text{heuristic}_{vertex}$$

Setiap kali kita melakukan _relaxation_ dan pemilihan, kita akan meng-_update_ kedua tabel tersebut.

__STEP 1__ Kita akan mulai dari `A`, maka:

```{r,echo=FALSE}
data.frame(node = c("A"),
           `g-score` = c(0),
           `f-score` = c(10),
           previous = c(NA)) %>% knitr::kable(caption = "Unvisited List - Step I")

data.frame(node = rep(" ",4),
           `g-score` = rep(" ",4),
           `f-score` = rep(" ",4),
           previous = rep(" ",4)) %>% knitr::kable(caption = "Visited List - Step II")
```

__STEP 2__ Pindahkan `A` ke dalam __visited list__. Lalu kita bisa beranjak ke `B`, `C`, dan `D`.

```{r,echo=FALSE}
data.frame(node = c("B","C","D"),
           `g-score` = c(10,12,5),
           `f-score` = c(25,17,10),
           previous = c("A","A","A")) %>% knitr::kable(caption = "Unvisited List - Step II")

data.frame(node = c("A"),
           `g-score` = c(0),
           `f-score` = c(10),
           previous = c(NA)) %>% knitr::kable(caption = "Visited List - Step II")
```

__STEP 3__ Pindahkan `D` ke dalam __visited list__ karena memiliki nilai `f-score` terendah. Lalu kita jadikan `D` sebagai patokan untuk melangkah. Kita bisa beranjak ke `C`, dan `F`. Perhatikan bahwa nilai `C` yang sebelumnya bisa kita _update_ jika `f-score` terbarunya ternyata __lebih kecil__ dari sebelumnya. 

> Perhatikan bahwa nilai `g-score` kali ini sudah merupakan penjumlahan dari dua _edges_!

```{r,echo=FALSE}
data.frame(node = c("B","C","F"),
           `g-score` = c(10,11,19),
           `f-score` = c(25,16,19),
           previous = c("A","D","D")) %>% knitr::kable(caption = "Unvisited List - Step III")

data.frame(node = c("A","D"),
           `g-score` = c(0,5),
           `f-score` = c(10,10),
           previous = c(NA,"A")) %>% knitr::kable(caption = "Visited List - Step III")
```


__STEP 4__ Pindahkan `C` ke dalam __visited list__ karena memiliki nilai `f-score` terendah. Lalu kita jadikan `C` sebagai patokan untuk melangkah. Kita bisa beranjak ke `E`, dan `F`. Perhatikan bahwa nilai `F` yang sebelumnya bisa kita _update_ jika `f-score` terbarunya ternyata __lebih kecil__ dari sebelumnya. 

> Perhatikan bahwa nilai `g-score` kali ini sudah merupakan penjumlahan dari tiga _edges_!

Perhatikan bahwa jalur `F` dari `D` dengan jalur `F` dari `C` memiliki nilai yang sama. Oleh karena itu kita akan tetap memilih jalur `F` dari `D` karena berasal dari iterasi yang sebelumnya.

```{r,echo=FALSE}
data.frame(node = c("B","E","F","F"),
           `g-score` = c(10,22,5+6+8,5+14),
           `f-score` = c(25,22+10,5+6+8,5+14),
           previous = c("A","C","C","D")) %>% knitr::kable(caption = "Unvisited List - Step III")

data.frame(node = c("A","D","C"),
           `g-score` = c(0,5,11),
           `f-score` = c(10,10,16),
           previous = c(NA,"A","D")) %>% knitr::kable(caption = "Visited List - Step III")
```


__STEP 5__ Pindahkan `F` jalur dari `D` ke dalam __visited list__ karena memiliki nilai `f-score` terendah.

```{r,echo=FALSE}
data.frame(node = c("B","E","F"),
           `g-score` = c(10,22,5+6+8),
           `f-score` = c(25,22+10,5+6+8),
           previous = c("A","C","C")) %>% knitr::kable(caption = "Unvisited List - Step III")

data.frame(node = c("A","D","C","F"),
           `g-score` = c(0,5,11,5+14),
           `f-score` = c(10,10,16,5+14),
           previous = c(NA,"A","D","D")) %>% knitr::kable(caption = "Visited List - Step III")
```

#### Kesimpulan {-}

Jalur yang dilalui adalah __A - D - F__.

```{r,include=FALSE}
rm(list=ls())
```

#### __R__ _Function_ _A-Star_ {-}

Sekarang kita akan membuat _function_ mandiri dari algoritma _A-Star_ ini. Seperti biasa, inputnya adalah _data frame_ untuk grafnya dan nilai _heuristic_-nya.

```{r,echo=FALSE}
graf_df = data.frame(from  = c('a','b','a','d','a','c','c','d','b','e','c','e','c','f','d','f'),
                     to    = c('b','a','d','a','c','a','d','c','e','b','e','c','f','c','f','d'),
                     bobot = c(10,10,5,5,12,12,6,6,11,11,11,11,8,8,14,14)
                     )
graf_df

d_titik = data.frame(titik = c('a','b','c','d','e','f'),
                     bobot = c(10,15,5,5,10,0)
                     )
d_titik
```

Berikut adalah langkahnya:

```{r,message=FALSE,warning=FALSE}
# function ambil nilai heuristic
heureuy = function(v){
  h = d_titik %>% filter(titik == v)
  h = h$bobot
  return(h)
}

# bikin rumah
visited = data.frame(from = NA,
                     to = NA,
                     g_skor = NA,
                     f_skor = NA)
unvisited = data.frame(from = NA,
                       to = NA,
                       g_skor = NA,
                       f_skor = NA)


# step 1
start = "a"
visited[1,] = list(NA,start,0,d_titik$bobot[d_titik$titik == start])

# step 2
temp = 
  graf_df %>% 
  filter(from == start) %>% 
  rowwise() %>% 
  mutate(g_skor = bobot,
         f_skor = g_skor + heureuy(to)) %>% 
  ungroup() %>% 
  select(-bobot)

pivot = temp %>% filter(f_skor == min(f_skor))
visited[2,] = pivot
unvisited = temp %>% filter(f_skor != min(f_skor))

visited
unvisited

# step 3
temp = 
  graf_df %>% 
  filter(from == pivot$to) %>% 
  filter(to != start) %>% 
  rowwise() %>% 
  mutate(g_skor = bobot + visited$g_skor[visited$to == from],
         f_skor = g_skor + heureuy(to)) %>% 
  ungroup() %>% 
  select(-bobot)

pivot = temp %>% filter(f_skor == min(f_skor))
visited[3,] = pivot
unvisited = temp %>% filter(f_skor != min(f_skor))

visited
unvisited

# step 4
temp = 
  graf_df %>% 
  filter(from == pivot$to) %>% 
  filter(to != start) %>% 
  rowwise() %>% 
  mutate(g_skor = bobot + visited$g_skor[visited$to == from],
         f_skor = g_skor + heureuy(to)) %>% 
  ungroup() %>% 
  select(-bobot)

pivot = temp %>% filter(f_skor == min(f_skor))
visited[4,] = pivot
unvisited = temp %>% filter(f_skor != min(f_skor))

visited
unvisited
```

Ini juga perlu ada subjektivitas dalam melihat hasilnya. Kita bisa jadikan _step_ 3 dan _step_ 4 dalam bentuk _looping_ dengan `while()`.

```{r,include=FALSE}
rm(list=ls())
```

#### __R__ _Function_ dari Sumber Lain {-}

Sumbernya dari sini^[https://www.algorithms-and-technologies.com/a_star/r].

```{r}
a_star <- function(graph, heuristic, start, goal) {
  #' Finds the shortest distance between two nodes using the A-star (A*) algorithm
  #' @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.
  #' @param heuristic an estimation of distance from node x to y that is guaranteed to be lower than the actual distance. E.g. straight-line distance
  #' @param start the node to start from.
  #' @param goal the node we're searching for
  #' @return The shortest distance to the goal node. Can be easily modified to return the path.

  # This contains the distances from the start node to all other nodes, initialized with a distance of "Infinity"
  distances = rep(Inf, nrow(graph))
  
  # The distance from the start node to itself is of course 0
  distances[start] = 0
  
  # This contains the priorities with which to visit the nodes, calculated using the heuristic.
  priorities = rep(Inf, nrow(graph))
  
  # start node has a priority equal to straight line distance to goal. It will be the first to be expanded.
  priorities[start] = heuristic[start,goal]
  
  # This contains whether a node was already visited
  visited = rep(FALSE, nrow(graph))
  
  # While there are nodes left to visit...
  repeat {
    # ... find the node with the currently lowest priority...
    lowest_priority = Inf
    lowest_priority_index = -1
    for(i in seq_along(priorities)) {
      # ... by going through all nodes that haven't been visited yet
      if(priorities[i] < lowest_priority && !visited[i]){
        lowest_priority = priorities[i]
        lowest_priority_index = i
      }
    }
    if (lowest_priority_index == -1){
      # There was no node not yet visited --> Node not found
      return (-1)
    } else if (lowest_priority_index == goal){
      # Goal node found
      print("Goal node found!")
      return(distances[lowest_priority_index])
    }
    cat("Visiting node ", lowest_priority_index, " with currently lowest priority of ", lowest_priority)
    
    # ...then, for all neighboring nodes that haven't been visited yet....
    for(i in seq_along(graph[lowest_priority_index,])) {
      if(graph[lowest_priority_index,i] != 0 && !visited[i]){
        # ...if the path over this edge is shorter...
        if(distances[lowest_priority_index] + graph[lowest_priority_index,i] < distances[i]){
          # ...save this path as new shortest path
          distances[i] = distances[lowest_priority_index] + graph[lowest_priority_index,i]
          # ...and set the priority with which we should continue with this node
          priorities[i] = distances[i] + heuristic[i,goal]
          cat("\nUpdating distance of node ", i, " to ", distances[i], " and priority to ", priorities[i], "\n")
        }
        # Lastly, note that we are finished with this node.
        visited[lowest_priority_index] = TRUE
        cat("\nVisited nodes: ", visited, "\n")
        cat("Currently lowest distances: ", distances, "\n")
      }
    }
  }
}
```


Kita ubah dulu inputnya menjadi matriks:

```{r,message=FALSE,warning=FALSE}
# perhatikan ada modifikasi pada bagian 1-1 dan 6-6 agar matriks 
# yang dihasilkan sempurna dimensinya nxn
graf_df = data.frame(from  = c('a','b','a','d','a','c','c','d','b','e','c','e','c','f','d','f'),
                     to    = c('b','a','d','a','c','a','d','c','e','b','e','c','f','c','f','d'),
                     bobot = c(10,10,5,5,12,12,6,6,11,11,11,11,8,8,14,14)
                     )

heri = matrix(c(10,15,5,5,10,0,
                10,15,5,5,10,0,
                10,15,5,5,10,0,
                10,15,5,5,10,0,
                10,15,5,5,10,0,
                10,15,5,5,10,0),
              byrow = T,
              ncol = 6)


graf_new = 
  graf_df %>% 
  reshape2::dcast(from~to,
                  value.var = "bobot") %>% 
  select(-from)

graf_new[is.na(graf_new)] = 0
graf_new = as.matrix(graf_new)

graf_new
heri
```

Mari kita coba _function_-nya:

```{r}
a_star(graf_new, heri, 1, 6)
```

Agak pusing dilihatnya tapi bener hasilnya sama dengan _function_ sendiri.

\newpage

# PERTEMUAN MINGGU VI

## _Genetic Algorithm_

Algoritma yang didasarkan dari _natural selection_. Karena ini _heuristic_, maka tidak ada jaminan bahwa solusi yang ada sudah paling optimal karena bergantung dari pemilihan _parent solution_. Perhatikan istilahnya bernama _parent_, karena ini mengikuti biologi. Dari _parent_ bermutasi sampai jadi solusi. Kalau di analisa numerik kan disebutnya _initial solution_.

### _Advantages vs Disadvantages_

### _Basic Terminology_

- ___Population___ adalah semua kemungkinan solusi yang ada dari permasalahan.
- ___Chromosomes___ adalah __satu solusi__ dari permasalahan kita.
- ___Gene___ adalah __satu elemen__ dari suatu solusi yang ada.
- ___Allele___ adalah __isi__ dari suatu elemen solusi.
- ___Genotype___ adalah populasi dari _computation space_.
- ___Phenotype___ adalah populasi dari solusi real.
- ___Decoding___ adalah proses dari _Genotype_ ke _Phenotype_.
- ___Encoding___ adalah proses dari _Phenotype_ ke _Genotype_.
- ___Fitness Function___ adalah fungsi yang mengukur seberapa __cocok__ suatu solusi.
- ___Genetic Operators___ adalah proses alterasi dari kromosom. Bisa berupa _crossover_, mutasi, seleksi, dan lainnya.


```{r out.width="30%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Basic Terminology"}
knitr::include_graphics("Screenshot from 2021-10-07 07-38-10.png")
```

\newpage

### _Basic Structure_

Berikut adalah _flow_ dari _genetic algorithm_:

```{r out.width="35%",echo=FALSE,fig.align='center',fig.retina=10,fig.cap="GA Flow"}
nomnoml::nomnoml("#direction: down,
                 [Population|initialization] -> [Fitness|Function Calculations]
                 [Fitness] -> [Crossover]
                 [Crossover] -> [Mutation]
                 [Mutation] -> [Survivor|Selection]
                 [Survivor] -> [Terminate|Return the best]
                 
                 [Survivor] --> iteration [Fitness]
                 ")
```

Salah satu tantangan dalam _GA_ adalah menentukan populasi awalnya.

### Contoh Soal^[https://towardsdatascience.com/genetic-algorithm-explained-step-by-step-65358abe2bf]

Diberikan $2a^2 + b = 57$. Tentukan nilai $a,b$ dengan _GA_ yang meminimumkan:

$$f(a,b) = 2a^2 + b - 57$$

#### Jawab {-}

__STEP I__ kita akan buat suatu populasi. Kita bisa _set_ misalkan ada 6 kromosom secara _random_.

```{r,echo=FALSE}
rm(list=ls())
set.seed(101042)
intial_popu <- NULL
x <- 1
repeat {
  crm <- runif(2,1,10)
  crm <- as.integer(crm)
  intial_popu <- rbind(intial_popu,crm)
  x = x+1
  if (x == 7){
    break
  }
}
rownames(intial_popu) <- c('Cromosome1','Cromosome2','Cromosome3','Cromosome4','Cromosome5','Cromosome6')
print(intial_popu)
```


__STEP II__ proses _selection_, yakni memilih _fittest_ kromosom. Caranya adalah dengan menghitung _fitness value_. Kromosom yang menghasilkan _low values_ akan dipilih untuk generasi berikutnya.

Kita akan gunakan metode _roulette wheel_, yakni dengan menghitung:

$$FP = \frac{F_i}{\sum_{i=1}^n F_i}$$

Di mana $FP$ menandakan _fitness probability_ dan $F_i$ menandakan _fitness value_.

Untuk memilih _fittest_ kromosom, kita akan generate __6 random probabilities__.


```{r,echo=FALSE}
## Function to compute fitness
fit <- function(A){
  a <- A[1]
  b <- A[2]
  return(((2*a^2 + b) - 57))
}
fitness <- apply(intial_popu, 1, FUN = 'fit')
fitting <- 1/(fitness)
probfitting <- fitting/sum(fitting)
#generate random values of fitness prob. from 0 to 1
prob_gen <- runif(6,0,1)
newpopulation <- NULL
for(rr in prob_gen){
  sum <- 0
  for(prob in probfitting){
    sum <- sum + prob
    if(rr < sum){
      bin <- prob
      cromosomeS <- which(probfitting == bin, arr.ind = T)
      if(length(cromosomeS)>1){
        cromosomeS <- cromosomeS[1]
      } else{
        cromosomeS <- cromosomeS
      }
      cromname <- paste0('Cromosome',cromosomeS[1])
      newcromosome <- intial_popu[which(rownames(intial_popu) == cromname),]
      break
    }
  }
  newpopulation <- rbind(newpopulation,newcromosome,deparse.level = 2)
}
rownames(newpopulation) <- rownames(intial_popu) 
print(newpopulation)
```

Kita akan memilih kromosom yang jatuh di titik `ran_prob` sebagai _parents_ di generasi berikutnya.

__STEP III__ Berikutnya kita akan ubah nilai $a$ dan $b$ menjadi _binary_ lalu menggabungkannya. Saya akan gunakan sistem 4 _bits_, sehingga akan didapatkan 8 _bits_.

Kemudian kita akan lakukan _crossover_ atau perkawinan silang. Kita _set_ terlebih dahulu _crossover rate_. Misalkan `0.5`, artinya dari `6` kromosom, hanya `3` yang boleh __kawin__.

```{r,echo=FALSE}
##Function to convert integer to binary
binary <- function(x) {
  i <- 0
  string <- numeric(32)
  while(x > 0) {
    string[32 - i] <- x %% 2
    x <- x %/% 2
    i <- i + 1 
  }
  first <- match(1, string)
  string[first:32] 
}
##create binary matrix of 8 cols and 6 rows
binary_popu <- matrix(NA,nrow = 6,ncol = 8)
for(i in 1:nrow(newpopulation)){
 x <- binary(newpopulation[i,1])
binary_popu[i,1:length(x)] <- x
y <- binary(newpopulation[i,2])
binary_popu[i,5:(4+length(y))] <- y
  }
rownames(binary_popu) <- rownames(newpopulation)
cross_paramter <- 0.5
i = 1
crom_cross <- NULL
while(length(crom_cross) < 3){
  cross.crossover.prob <- runif(6,0,1)
  crom_cross <- which(cross.crossover.prob < cross_paramter,arr.ind = T)
  i = i + 1
}
parents <- binary_popu[crom_cross,]
position = 2 ##crossover position
cross_parent <- parents
cross_parent[1,1:position] <- parents[2,1:position]
cross_parent[2,1:position] <- parents[3,1:position]
cross_parent[3,1:position] <- parents[1,1:position]

listofindex <- which(row.names(binary_popu) %in% row.names(cross_parent))
offSpring <- binary_popu
offSpring[listofindex,] <- cross_parent
print(offSpring) ##offspring after crossover
```

__STEP IV__ Kita akan lakukan _mutation_. _Mutation rate_ juga harus kita definisikan terlebih dahulu.

```{r,echo=FALSE}
mutation_paramter <- 0.09
no.of.mutations <- 4  ## Calculated as nrow(offSpring)*ncol(offSpring)*mutation_paramter

randrow <- round(runif(no.of.mutations,1,nrow(offSpring)))
rancol <-  round(runif(no.of.mutations,1,ncol(offSpring)))

## Now get the offsprings by mutating at above position
for(r in 1:length(randrow)){
  if(is.na(offSpring[randrow[r],rancol[r]])){
    offSpring[randrow[r],rancol[r]] <- NA
  }else{
    if(offSpring[randrow[r],rancol[r]] == 0){
      offSpring[randrow[r],rancol[r]] <- 1
    }else{
      offSpring[randrow[r],rancol[r]] <- 0
    }
  }
}

print(offSpring) ## Chromosomes after mutation

## Now convert binary back to integer
binary_decimal = function(base_number, base = 2) {
  split_base = strsplit(as.character(base_number), split = "")
  return(sapply(split_base, function(x) sum(as.numeric(x) * base^(rev(seq_along(x) - 1)))))
}
offSpring_inter <- matrix(NA,6,2)
for(i in 1:nrow(offSpring)){
  a <- offSpring[i,1:4]
  a <- na.omit(a)
  a <- as.numeric(paste(a, collapse = ""))
  a <- binary_decimal(a)
  b <- offSpring[i,5:8]
  b <- na.omit(b)
  b <- as.numeric(paste(b, collapse = ""))
  b <- binary_decimal(b)
  offSpring_inter[i,1] <- a
  offSpring_inter[i,2] <- b
}
rownames(offSpring_inter) <- rownames(offSpring)
## Chromosomes converted back to integer after end of 1st of generation
print(offSpring_inter)
```

Proses di atas kita lakukan berulang-uang hingga mendapatkan hasil paling optimal.

\newpage

# PERANCANGAN PERANGKAT LUNAK

## _Waterfall Model_

Lima tahapan:

1. _Defining and understanding the problem_.
1. _Planning dan designing solution_.
1. _Implementing solution_.
1. _Testing and evaluation the solution_.
1. _Maintenance_.

## _Context Diagram_

Digunakan untuk mendefinisikan masalah. Isinya berupa:

1. ___System___: _big picture of your problems_.
1. ___Data flow___: _needs and wants_.
    - _Needs_: yang perlu diselesaikan oleh si perancang _software_.
    - _Wants_: _features_ yang diinginkan pengguna. 
1. ___External entities___: _big picture of your subject_.

\newpage

Contoh _context diagram_ kelompok kuliah beberapa tahun yang lalu:

```{r out.width="85%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Context Diagram"}
knitr::include_graphics("context.png")
```

Bisa juga disajikan dalam bentuk tabel sebagai berikut:

```{r out.width="85%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Needs and Wants External Entities"}
knitr::include_graphics("tabel.png")
```

\newpage

## _Data Flow Diagram_

Suatu _graphical modeling tool to depict data flow through a system and the work or processing performed by that system_. Diagram ini menggunakan simbol-simbol tertentu.

```{r out.width="85%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Penggunaan Simbol DFD"}
knitr::include_graphics("Screenshot from 2021-10-21 07-41-49.png")
```

\newpage

Contoh DFD:

```{r out.width="85%",echo=FALSE,fig.retina=10,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Contoh DFD"}
knitr::include_graphics("Screenshot from 2021-10-21 07-42-03.png")
```

Aturan:

1. Setiap proses harus memiliki minimal satu input dan output.
1. Setiap data yang di-_store_ harus memiliki minimal satu data _flow in_ dan _flow out_.


\newpage

# EPILOG

## Tugas Kuliah

Tugas kuliah individu bisa diakses di _repository_ berikut ini^[https://github.com/ikanx101/209_ITB/tree/main/Semester%20I/Algorithm%20and%20Software%20Design/Tugas]. 

