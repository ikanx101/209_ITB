---
title: SPIRAL OPTIMIZATION ALGORITHM
subtitle: |
  | Tugas Kuliah
  | SK5001 Analisis Numerik Lanjut
author: |
  | Mohammad Rizka Fadhli
  | NIM: 20921004
date: "`r format(Sys.time(), '%d %B %Y')`"
fotsize: 12pt
output:
  pdf_document:
   number_section: false
   toc: false
   highlight: tango
   dev: png
---

```{r setup, include=FALSE}
rm(list=ls())
options(digits = 6)

library(dplyr)
library(ggplot2)
```

# PENDAHULUAN

## Bahasa yang Digunakan

Untuk membuat program _spiral optimization algorithm_, saya menggunakan bahasa __R__ yang bisa dieksekusi pada versi minimal `3.5.3`.

## Spiral Optimization Algorithm

_Spiral Optimization Algorithm_ adalah salah satu metode _meta heuristic_ yang digunakan untuk mencari minimum global dari suatu sistem persamaan. 

Algoritmanya mudah dipahami dan intuitif tanpa harus memiliki latar keilmuan tertentu. Proses kerjanya adalah dengan melakukan _random number generating_ pada suatu selang dan melakukan rotasi sekaligus kontraksi dengan titik paling minimum pada setiap iterasi sebagai pusatnya.

Berikut adalah algoritmanya:

```
INPUT
  m >= 2 # jumlah titik
  theta  # sudut rotasi (0 <= theta <= 2pi)
  r      # konstraksi
  k_max  # iterasi maksimum

PROCESS
  1 generate m buah titik secara acak
      x_i

  2 initial condition
      k = 0 # untuk keperluan iterasi

  3 cari x_* yang memenuhi
      min(f(x_*))
  
  4 lakukan rotasi dan konstraksi semua x_i
      x_* sebagai pusat rotasi
      k = k + 1

  5 ulangi proses 3 dan 4

  6 hentikan proses saat k = k_max
      output x_*
```

Berdasarkan algoritma di atas, salah satu proses yang penting adalah melakukan __rotasi__ dan __konstraksi__ terhadap semua titik yang telah di-_generate_.

Agar memudahkan, saya akan memberikan ilustrasi geometri beserta operasi matriks aljabar terkait kedua hal tersebut.

## Membuat Program 

Untuk menyelesaikan tugas soal yang diberikan, pertama-tama saya harus membuat program _spiral optimization algorithm_. Untuk membuatnya, saya akan melakukannya perlahan-lahan dengan bantuan ilustrasi geometri. Berikut adalah langkah-langkah yang ditempuh:

1. __Pertama__ saya akan membuat program yang bisa merotasi suatu titik berdasarkan suatu $\theta$ tertentu.
1. __Kedua__ saya akan memodifikasi program tersebut untuk melakukan rotasi sekaligus konstraksi dengan rasio $r$ tertentu.
1. __Ketiga__ saya akan memodifikasi program tersebut untuk melakukan rotasi sekaligus konstraksi dengan __titik pusat rotasi tertentu__.

Dari program yang terakhir, akan saya pakai untuk __membangun program__ ___spiral optimization algorithm___ yang sebenarnya.

## Langkah dan Ilustrasi Geometri

### Operasi Matriks Rotasi

Misalkan saya memiliki titik $x \in \mathbb{R}^2$. Untuk melakukan rotasi sebesar $\theta$, saya bisa menggunakan suatu matriks $A_{2 \times 2}$ berisi fungsi-fungsi trigonometri sebagai berikut:

$$\begin{bmatrix} x_1 (k+1) \\ x_2 (k+1) \end{bmatrix} = \begin{bmatrix} \cos{\theta} & -\sin{\theta} \\ \sin{\theta} & \cos{\theta} \end{bmatrix} \begin{bmatrix} x_1 (k) \\ x_2 (k) \end{bmatrix}$$

Berdasarkan operasi matriks di atas, saya membuat __program__ di __R__ dengan beberapa modifikasi. Sebagai contoh, saya akan membuat program yang bertujuan untuk melakukan rotasi suatu titik $x \in \mathbb{R}$ sebanyak $n$ kali:

```{r,include = FALSE}
# function untuk random titik
rand_titik = function(a,b){
  runif(2,a,b)
}
```

```{r}
# mendefinisikan program
rotasi_kan = function(x0,rot){
  # menghitung theta
  theta = 2*pi/rot

  # definisi matriks rotasi
  A = matrix(c(cos(theta),-sin(theta),
             sin(theta),cos(theta)),
           ncol = 2,byrow = T)
  
  # membuat template
  temp = vector("list")
  temp[[1]] = x0

  # proses rotasi
  for(i in 2:rot){
    xk = A %*% x0
    temp[[i]] = xk
    x0 = xk
  }
  
  # membuat template data frame
  final = data.frame(x = rep(NA,rot),
                     y = rep(NA,rot))
  
  # gabung data dari list
  for(i in 1:rot){
    tempura = temp[[i]]
    final$x[i] = tempura[1]
    final$y[i] = tempura[2]
  }

  # membuat plot
  plot = 
    ggplot() +
    geom_point(aes(x,y),data = final) +
    geom_point(aes(x[1],y[1]),
               data = final,
               color = "red") +
    coord_equal() +
    labs(title = "titik merah adalah titik initial") 
  
  # enrich dengan garis panah
  panah = data.frame(
    x_start = final$x[1:(rot-1)],
    x_end = final$x[2:rot],
    y_start = final$y[1:(rot-1)],
    y_end = final$y[2:rot]
  )
  # menambahkan garis panah ke plot
  plot = 
    plot + 
    geom_segment(aes(x = x_start,
                 xend = x_end,
                 y = y_start,
                 yend = y_end),
                 data = panah,
                 arrow = arrow(length = unit(.3,"cm"))
                 )
  
  # menyiapkan output
  list("Grafik rotasi" = plot,
       "Titik-titik rotasi" = final)
  }
```

\newpage

Berikut adalah uji coba dengan titik sembarang berikut ini:

```{r,fig.align="center",fig.retina = 10,fig.caption = "Uji Coba Rotasi I"}
# uji coba
rot = 12 # berapa banyak rotasi
x0 = rand_titik(0,10) # generate random titik

rotasi_kan(x0,rot)
```

\newpage

Uji coba kembali dengan titik sembarang lainnya berikut ini:

```{r,fig.align="center",fig.retina = 10,fig.caption = "Uji Coba Rotasi II"}
# uji coba
rot = 7 # berapa banyak rotasi
x0 = rand_titik(0,10) # generate random titik

rotasi_kan(x0,rot)
```

\newpage

### Operasi Matriks Rotasi dan Kontraksi

Jika pada sebelumnya saya __hanya melakukan rotasi__, kali ini saya akan memodifikasi operasi matriks agar melakukan rotasi dan konstraksi secara bersamaan. Untuk melakukan hal tersebut, saya akan definisikan $r,0<r<1$ dan melakukan operasi matriks sebagai berikut:

$$\begin{bmatrix} x_1 (k+1) \\ x_2 (k+1) \end{bmatrix} = \begin{bmatrix} r \\ r \end{bmatrix} \begin{bmatrix} \cos{\theta} & -\sin{\theta} \\ \sin{\theta} & \cos{\theta} \end{bmatrix} \begin{bmatrix} x_1 (k) \\ x_2 (k) \end{bmatrix}$$

Oleh karena itu saya akan modifikasi program __R__ sebelumnya menjadi sebagai berikut:

```{r}
# mendefinisikan program
rotasi_konstraksi_kan = function(x0,rot,r){
  # menghitung theta
  theta = 2*pi/rot

  # definisi matriks rotasi
  A = matrix(c(cos(theta),-sin(theta),
             sin(theta),cos(theta)),
           ncol = 2,byrow = T)
  
  # membuat template
  temp = vector("list")
  temp[[1]] = x0

  # proses rotasi dan konstraksi
  for(i in 2:rot){
    xk = A %*% x0
    xk = r * xk
    temp[[i]] = xk
    x0 = xk
  }
  
  # membuat template data frame
  final = data.frame(x = rep(NA,rot),
                     y = rep(NA,rot))
  
  # gabung data dari list
  for(i in 1:rot){
    tempura = temp[[i]]
    final$x[i] = tempura[1]
    final$y[i] = tempura[2]
  }

  # membuat plot
  plot = 
    ggplot() +
    geom_point(aes(x,y),data = final) +
    geom_point(aes(x[1],y[1]),
               data = final,
               color = "red") +
    coord_equal() +
    labs(title = "titik merah adalah titik initial") 
  
  # enrich dengan garis panah
  panah = data.frame(
    x_start = final$x[1:(rot-1)],
    x_end = final$x[2:rot],
    y_start = final$y[1:(rot-1)],
    y_end = final$y[2:rot]
  )
  # menambahkan garis panah ke plot
  plot = 
    plot + 
    geom_segment(aes(x = x_start,
                 xend = x_end,
                 y = y_start,
                 yend = y_end),
                 data = panah,
                 arrow = arrow(length = unit(.3,"cm"))
                 )
  
  # menyiapkan output
  list("Grafik rotasi" = plot,
       "Titik-titik rotasi" = final)
  }
```

\newpage

Saya akan uji coba untuk sembarang titik berikut ini:

```{r,fig.align="center",fig.retina = 10,fig.caption = "Uji Coba Rotasi-Konstraksi I"}
# uji coba
rot = 25 # berapa banyak rotasi
x0 = rand_titik(0,4) # generate random titik
r = .9
rotasi_konstraksi_kan(x0,rot,r)
```

\newpage

Saya akan uji coba kembali untuk sembarang titik lainnya berikut ini:

```{r,fig.align="center",fig.retina = 10,fig.caption = "Uji Coba Rotasi-Konstraksi II"}
# uji coba
rot = 10 # berapa banyak rotasi
x0 = rand_titik(0,4) # generate random titik
r = .7
rotasi_konstraksi_kan(x0,rot,r)
```

__Catatan penting:__

Terlihat bahwa semakin banyak rotasi dan konstraksi yang dilakukan akan membuat titik _initial_ __menuju pusat__ $(0,0)$.

\newpage

### Operasi Matriks Rotasi dan Kontraksi dengan Titik $x^*$ Sebagai Pusatnya

Salah satu prinsip utama dari _spiral optimization algorithm_ adalah menjadikan titik $x^*$ sebagai pusat rotasi di setiap iterasinya. Operasi matriksnya adalah sebagai berikut:

$$\begin{bmatrix} x_1 (k+1) \\ x_2 (k+1) \end{bmatrix} = \begin{bmatrix} x_1^* \\ x_2^* \end{bmatrix} + \begin{bmatrix} r \\ r \end{bmatrix} \begin{bmatrix} \cos{\theta} & -\sin{\theta} \\ \sin{\theta} & \cos{\theta} \end{bmatrix} ( \begin{bmatrix} x_1 (k) \\ x_2 (k) \end{bmatrix} - \begin{bmatrix} x_1^* \\ x_2^* \end{bmatrix} )$$


Oleh karena itu kita akan modifikasi program bagian sebelumnya menjadi seperti ini:

```{r}
# mendefinisikan program
rotasi_konstraksi_pusat_kan = function(x0,rot,r,x_bin){
  # pusat rotasi
  pusat = x_bin

  # menghitung theta
  theta = 2*pi/rot

  # definisi matriks rotasi
  A = matrix(c(cos(theta),-sin(theta),
             sin(theta),cos(theta)),
           ncol = 2,byrow = T)
  
  # membuat template
  temp = vector("list")
  temp[[1]] = x0

  # proses rotasi dan konstraksi
  for(i in 2:rot){
    xk = A %*% (x0-pusat) # diputar dengan x_bin sebagai pusat
    xk = pusat + (r * xk)
    temp[[i]] = xk
    x0 = xk
  }
  
  # membuat template data frame
  final = data.frame(x = rep(NA,rot),
                     y = rep(NA,rot))
  
  # gabung data dari list
  for(i in 1:rot){
    tempura = temp[[i]]
    final$x[i] = tempura[1]
    final$y[i] = tempura[2]
  }

  # membuat plot
  plot = 
    ggplot() +
    geom_point(aes(x,y),data = final) +
    geom_point(aes(x[1],y[1]),
               data = final,
               color = "red") +
    geom_point(aes(x = pusat[1],
		   y = pusat[2]),
	       color = "blue") +
    labs(title = "titik merah adalah titik initial\ntitik biru adalah pusat rotasi") 
  
  # enrich dengan garis panah
  panah = data.frame(
    x_start = final$x[1:(rot-1)],
    x_end = final$x[2:rot],
    y_start = final$y[1:(rot-1)],
    y_end = final$y[2:rot]
  )
  # menambahkan garis panah ke plot
  plot = 
    plot + 
    geom_segment(aes(x = x_start,
                 xend = x_end,
                 y = y_start,
                 yend = y_end),
                 data = panah,
                 arrow = arrow(length = unit(.3,"cm"))
                 )
  
  # menyiapkan output
  list("Grafik rotasi" = plot,
       "Titik-titik rotasi" = final)
  }
```

\newpage

Saya akan coba dengan sembarang titik berikut:

```{r,fig.align="center",fig.retina = 10,fig.caption = "Uji Coba Rotasi-Konstraksi Terhadap x* I"}
# uji coba
rot = 10 # berapa banyak rotasi
x0 = rand_titik(0,4) # generate random titik
x_bintang = c(0,1) # contoh pusat rotasi
r = .6
rotasi_konstraksi_pusat_kan(x0,rot,r,x_bintang)
```

\newpage

Saya akan coba kembali dengan sembarang titik lainnya:

```{r,fig.align="center",fig.retina = 10,fig.caption = "Uji Coba Rotasi-Konstraksi Terhadap x* II"}
# uji coba
rot = 20 # berapa banyak rotasi
x0 = rand_titik(0,10) # generate random titik
x_bintang = c(2,3) # contoh pusat rotasi
r = .9
rotasi_konstraksi_pusat_kan(x0,rot,r,x_bintang)
```

\newpage

## Program _Spiral Optimization Algorithm_

Berbekal program yang telah dituliskan di bagian sebelumnya, kita akan sempurnakan program untuk melakukan _spiral optimization_ sebagai berikut:

```{r}
soa_mrf = function(N,	  # banyak titik
		   a,	  # batas bawah
		   b,	  # batas atas
		   rot,	  # berapa banyak rotasi
		   k_max, # iterasi maks
		   r){	  # berapa rate konstraksi

# N pasang titik random di selang [a,b] di R2
x1 = runif(N,a,b)
x2 = runif(N,a,b)

# hitung theta
theta = 2*pi / rot

# definisi matriks rotasi
A = matrix(c(cos(theta),-sin(theta),
             sin(theta),cos(theta)),
           ncol = 2,byrow = T)

# bikin data frame
temp = data.frame(x1,x2) %>% mutate(f = f(x1,x2))

# proses iterasi
for(i in 1:k_max){
  # mencari titik x* dengan min(f)
  f_min = temp %>% filter(f == min(f))
  pusat = c(f_min$x1,f_min$x2)

  for(j in 1:N){
	# kita akan ambil titiknya satu persatu
	x0 = c(temp$x1[j],temp$x2[j])
	
	# proses rotasi dan konstraksi terhadap pusat x*
	xk = A %*% (x0-pusat) # diputar dengan x_bin sebagai pusat
        xk = pusat + (r * xk)
	
	# proses mengembalikan nilai ke temp
	temp$x1[j] = xk[1]
	temp$x2[j] = xk[2]
	}
    
    # hitung kembali nilai f(x1,x2)
    temp = temp %>% mutate(f = f(x1,x2))
    }

# proses output hasil
output = temp %>% filter(f == min(f))
return(output)
}

```

\newpage

### Contoh Penggunaan Program

Kita akan coba performa program tersebut untuk menyelesaikan fungsi berikut:

$$f(x_1,x_2) = \frac{x_1^4 - 16 x_1^2 + 5 x_1}{2} + \frac{x_2^4 - 16 x_2^2 + 5 x_2}{2}$$

$$-4 \leq x_1,x_2 \leq 4$$

Dengan $r = 0.8, N = 50, rot = 20, k_{max} = 60$.

```{r}
# definisi
N = 50
a = -4
b = 4
k_max = 60
r = .8
rot = 20
f = function(x1,x2){
	((x1^4 - 16 * x1^2 + 5 * x1)/2) + ((x2^4 - 16 * x2^2 + 5* x2)/2)
	}

# solving
soa_mrf(N,a,b,rot,k_max,r)
```

__Catatan__

Pada algoritma ini, penentuan $\theta, r, x$ menjadi penentu hasil perhitungan.

\newpage

```{r,include=FALSE}
# untuk contour plot
ikanx = function(f,a,b){
  x = seq(a,b,by = .25)

  temp_plot =
    expand.grid(x,x) %>%
    rename(x = Var1,
           y = Var2) %>%
    mutate(z = f(x,y))

  temp_plot %>%
     ggplot(aes(x = x,y = y,z = z)) +
     geom_contour()
}

# untuk sistem persamaan
ikanx_2 = function(f,a,b){
  x = seq(a,b,by = .1)

  temp_plot =
    expand.grid(x,x) %>%
    rename(x = Var1,
           y = Var2) %>%
    mutate(z = f(x,y)) %>%
    filter(round(z,1) == 0)

  return(temp_plot)
}


```

# SOAL 1

Tentukanlah akar-akar sistem persamaan berikut dengan __SOA__. Buatlah terlebih dahulu _contour plot_-nya:

$$f_1 (x_1,x_2) = \cos{(2 x_1)} - \cos{(2 x_2)} - 0.4 = 0$$

$$f_2 (x_1,x_2) = 2 (x_2 - x_1) + \sin{ (x_2) } - \sin{(x_1)} - 1.2 = 0$$

dengan $-10 \leq x_1,x_2 \leq 10$

# JAWAB

## _Contour Plot_

Pertama-tama, saya akan buat _contour plot_ dari $f_1 (x_1,x_2)$ sebagai berikut:

```{r out.width = "75%",echo=FALSE,fig.retina=10,fig.cap = "Contour Plot Soal 1: f1"}
f1 = function(x1,x2){cos(2* x1) - cos(2*x2) - 0.4}
ikanx(f1,-10,10) + labs(title = "Contour Plot f1(x1,x2)")
```

\newpage

Selanjutnya, saya akan buat _contour plot_ dari $f_2 (x_1,x_2)$ sebagai berikut:

```{r out.width = "75%",echo=FALSE,fig.retina=10,fig.cap = "Contour Plot Soal 1: f2"}
f2 = function(x1,x2){2*(x2 - x1) + sin(x2) - sin(x1) - 1.2}
ikanx(f2,-10,10) + labs(title = "Contour Plot f2(x1,x2)")
```

\newpage

## Grafik Sistem Persamaan

Kita akan mencari akar-akar sistem persamaan saat $f_1 = 0$ dan $f_2=0$ dengan bantuan grafik sebagai berikut:

```{r out.width = "75%",echo=FALSE,fig.retina=10,fig.cap = "Plot Soal 1: f1 dan f2"}
df1 = ikanx_2(f1,-10,10)
df2 = ikanx_2(f2,-10,10)

ggplot() +
  geom_point(data = df1, aes(x,y)) +
  geom_point(data = df2, aes(x,y))
```

\newpage

# SOAL 2

Tentukanlah akar-akar sistem persamaan berikut dengan __SOA__. Buatlah terlebih dahulu _contour plot_-nya:

$$f_1 (x_1,x_2) = \sin{(x_1)} \cos{(x_2)} + 2 \cos{(x_1)} \sin{(x_2)} = 0$$

$$f_2 (x_1,x_2) = \cos{(x_1)} \sin{(x_2)} + 2 \sin{(x_1)} \cos{(x_2)}  = 0$$

dengan $0 \leq x_1,x_2 \leq 2 \pi$

## _Contour Plot_

Pertama-tama, saya akan buat _contour plot_ dari $f_1 (x_1,x_2)$ sebagai berikut:

```{r out.width = "75%",echo=FALSE,fig.retina=10,fig.cap = "Contour Plot Soal 2: f1"}
f1 = function(x1,x2){sin(x1)*cos(x2) + 2*cos(x1)*sin(x2)}
ikanx(f1,0,2*pi) + labs(title = "Contour Plot f1(x1,x2)")
```

\newpage

Berikutnya adalah _contour plot_ dari $f_2 (x_1,x_2)$ sebagai berikut:

```{r out.width = "75%",echo=FALSE,fig.retina=10,fig.cap = "Contour Plot Soal 2: f2"}
f2 = function(x1,x2){cos(x1)*sin(x2) + 2*sin(x1)*cos(x2)}
ikanx(f2,0,2*pi) + labs(title = "Contour Plot f2(x1,x2)")
```
